function [xhat, meas] = filterTemplateLog(calAcc, calGyr, calMag)
    % FILTERTEMPLATE  Filter template
    %
    % This is a template function for how to collect and filter data
    % sent from a smartphone live.  Calibration data for the
    % accelerometer, gyroscope and magnetometer assumed available as
    % structs with fields m (mean) and R (variance).
    %
    % The function returns xhat as an array of structs comprising t
    % (timestamp), x (state), and P (state covariance) for each
    % timestamp, and meas an array of structs comprising t (timestamp),
    % acc (accelerometer measurements), gyr (gyroscope measurements),
    % mag (magnetometer measurements), and orint (orientation quaternions
    % from the phone).  Measurements not availabe are marked with NaNs.
    %
    % As you implement your own orientation estimate, it will be
    % visualized in a simple illustration.  If the orientation estimate
    % is checked in the Sensor Fusion app, it will be displayed in a
    % separate view.
    %
    % Note that it is not necessary to provide inputs (calAcc, calGyr, calMag).
    
    %% Setup necessary infrastructure
    m = mobiledev;
    m.AccelerationSensorEnabled = 1;
    m.AngularVelocitySensorEnabled = 1;
    m.MagneticSensorEnabled = 1;
    m.OrientationSensorEnabled = 1;
    m.logging = 1;
    pause(2)
    %% Filter settings
    t0 = [];  % Initial time (initialize on first data received)
    t = 0;
    n = 4;   % Assuming that you use q as state variable.
    % Add your filter settings here.
    T = m.SampleRate;

    % Current filter state.
    x = [1; 0; 0 ;0];
    P = eye(n, n);
    est_x = x;
    est_P = P;

    g = 9.81;
    alpha = 0.01;

    acc_outlier_thresh = 0.8;
    % mag_outlier_thresh = 0.0001;
    mag_outlier_thresh = 0.5;

    % Saved filter states.
    xhat = struct('t', zeros(1, 0),...
        'x', zeros(n, 0),...
        'P', zeros(n, n, 0));
    
    meas = struct('t', zeros(1, 0),...
        'acc', zeros(3, 0),...
        'gyr', zeros(3, 0),...
        'mag', zeros(3, 0),...
        'orient', zeros(4, 0));

    figure(1);
    subplot(1, 2, 1);
    ownView = OrientationView('Own filter', gca);  % Used for visualization.
    googleView = [];
    
    
    %% Filter loop
    while 1  % Repeat while data is available
        flag_acc = 0;
        flag_mag = 0;
        flag_gyro = 0;
        t = t + 1/m.SampleRate;  % Extract current time
        counter = 0;  % Used to throttle the displayed frame rate

        gyro = angvellog(m);
        acc = accellog(m);
        mag = magfieldlog(m);
        orientation = deg2rad(orientlog(m));  % Google's orientation estimate.

        N_acc = length(acc);
        N_mag = length(mag);
        N_gyro = length(gyro);
        N_orientation = length(orientation);

        if isempty(t0)  % Initialize t0
            t0 = t;
            [~, gyro_cov] = mean_cov(gyro(:,1),gyro(:,2), gyro(:,3));
            [acc_mean, acc_cov] = mean_cov(acc(:,1), acc(:,2), acc(:,3));
            [mag_mean, mag_cov] = mean_cov(mag(:,1), mag(:,2), mag(:,3));
            g0 = acc_mean;
            m0 = [0; sqrt(mag_mean(1,1)^2 + mag_mean(2,1)^2); mag_mean(3,1)];
            acc_cov = 1 * acc_cov;
            mag_cov = 10 * mag_cov;
            
        end

        N = min([N_gyro,N_mag,N_acc,N_orientation]);
        L_hat(1) = norm(mag(1,:));

        for i = 2:N
            if all(~isnan(gyro(i-1,:)))
                [est_x, est_P] = tu_qw(est_x, est_P, gyro(i-1,:)', T, gyro_cov);
                [est_x, est_P] = mu_normalizeQ(est_x, est_P);
                flag_gyro = 1;
                % disp("Predicted")
            else
                % disp("Skipping gyro")
                flag_gyro = 0;
            end

            % Accelerometer update
            if all(~isnan(acc(i-1,:))) && flag_gyro == 1
                if i < 3
                    if abs(norm(acc(i-1,:)) - g) < acc_outlier_thresh
                    [est_x_wa, est_P_wa] = mu_g(est_x, est_P, acc(i-1,:)', acc_cov, g0);
                    [est_x_, est_P_wa] = mu_normalizeQ(est_x_wa, est_P_wa);
                    disp("Updated with accelerometer")
                    else
                    disp("Skipping acc update - Outlier detected")
                    end
                else
                    if abs(norm(acc(i-1,:)) - norm(acc(i-2,:))) < acc_outlier_thresh
                        [est_x, est_P] = mu_g(est_x, est_P, acc(i-1,:)', acc_cov, g0);
                        [est_x, est_P] = mu_normalizeQ(est_x, est_P);
                        disp("Updated with accelerometer")
                    else
                        disp("Skipping acc update - Outlier detected")
                    end
                end
            else
                flag_acc = 0;
            end

            % Magnetometer update
            if all(~isnan(mag(i-1,:))) && flag_gyro == 1 % Mag measurements are available.
                if abs(norm(mag(i-1,:)) - L_hat(i-1)) < mag_outlier_thresh
                    [est_x, est_P] = mu_m(est_x, est_P, mag(i-1,:)', m0, mag_cov);
                    [est_x, est_P] = mu_normalizeQ(est_x, est_P);
                    L_hat(i) = (1-alpha) * L_hat(i-1) + alpha * norm(mag(i,:));
                    disp("Updated with magnetometer")
                    flag_mag = 1;
                else
                    disp('Skipping mag update - Outlier detected')
                    L_hat(i) = (1-alpha) * L_hat(i-1) + alpha * norm(mag(i,:));
                    flag_mag = 0;
                end
            else
                flag_mag = 0;
            end

            x = est_x';
            % if flag_acc == 1 | flag_mag == 1 
            %     x = est_x';
            % else
            %     x = eul2quat(orientation(i-1,:))';
            % end
            
            % Visualize result
            if rem(counter, 10) == 0
                setOrientation(ownView, x);
                title(ownView, 'OWN', 'FontSize', 16);
                if ~any(isnan(orientation))
                    if isempty(googleView)
                        subplot(1, 2, 2);
                        % Used for visualization.
                        googleView = OrientationView('Google filter', gca);
                    end
                    setOrientation(googleView, eul2quat(orientation(i-1,:)));
                    title(googleView, 'GOOGLE', 'FontSize', 16);
                end
            end
            counter = counter + 1;

            % Save estimates
            xhat.x(:, end+1) = x;
            xhat.P(:, :, end+1) = est_P;
            xhat.t(end+1) = t - t0;

            meas.t(end+1) = t - t0;
            meas.acc(:, end+1) = acc(i-1,:)';
            meas.gyr(:, end+1) = gyro(i-1,:)';
            meas.mag(:, end+1) = mag(i-1,:)';
            meas.orient(:, end+1) = eul2quat(orientation(i-1,:))';
        end
        acc = [];
        mag = [];
        gyro = [];
        orientation = [];
        discardlogs(m);
        pause(0.5)
    end
end